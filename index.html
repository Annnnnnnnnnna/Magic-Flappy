<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Flappy Game</title>
  <style>
    :root{
      --pipe: rgba(150, 110, 235, 0.96);
      --pipe-dark: rgba(80, 55, 150, 0.40);

      --ui: rgba(0, 0, 0, 0.55);
      --ui2: rgba(0, 0, 0, 0.38);
      --white: #fff;

      --vh: 1vh;
    }

    html, body{
      height:100%;
      margin:0;
      background:#000;
      overflow:hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      touch-action: manipulation;
      overscroll-behavior: none;
      -webkit-user-select: none;
      user-select: none;
    }

    body{
      position: fixed;
      inset: 0;
      width: 100%;
      height: calc(var(--vh) * 100);
    }

    #game{
      position:fixed;
      inset:0;
      width:100vw;
      height:calc(var(--vh) * 100);
      display:block;
      background:#000;
    }

    .overlay{
      position:fixed;
      inset:0;
      display:grid;
      place-items:center;
      padding:20px;
      color:var(--white);
      text-align:center;
      background:rgba(0,0,0,0.45);
      backdrop-filter: blur(4px);
      padding-top: calc(20px + env(safe-area-inset-top));
      padding-bottom: calc(20px + env(safe-area-inset-bottom));
      z-index: 10;
    }

    .panel{
      width:min(560px, 92vw);
      background:var(--ui);
      border:1px solid rgba(255,255,255,0.15);
      border-radius:18px;
      padding:18px 18px 14px;
      box-shadow:0 20px 60px rgba(0,0,0,0.35);
    }

    .title{
      font-size:clamp(22px, 3.3vw, 30px);
      font-weight:800;
      letter-spacing:0.3px;
      margin:0 0 10px;
    }

    .text{
      font-size:clamp(14px, 2.2vw, 16px);
      line-height:1.45;
      margin:0 0 14px;
      opacity:0.95;
    }

    .btn{
      appearance:none;
      border:0;
      border-radius:14px;
      padding:12px 16px;
      width:100%;
      cursor:pointer;
      font-weight:800;
      font-size:16px;
      color:#1a1026;
      background: linear-gradient(180deg, rgba(215,195,255,1), rgba(174,140,255,1));
      box-shadow:0 16px 36px rgba(174,140,255,0.28);
    }
    .btn:active{ transform: translateY(1px); }
    .btn.secondary{
      margin-top: 10px;
      color: #fff;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.20);
      box-shadow: none;
    }

    .hidden{ display:none; }

    #hud{
      position:fixed;
      left:0; right:0; top:0;
      padding: env(safe-area-inset-top) 12px 0;
      display:flex;
      justify-content:center;
      pointer-events:none;
      z-index: 6;
    }

    #score{
      margin-top:10px;
      padding:8px 12px;
      border-radius:999px;
      background:rgba(0,0,0,0.45);
      border:1px solid rgba(255,255,255,0.18);
      color:#fff;
      font-weight:900;
      font-size:clamp(14px, 2.5vw, 18px);
      letter-spacing:0.3px;
      text-shadow:0 2px 10px rgba(0,0,0,0.35);
      display:flex;
      gap:10px;
      align-items:center;
      white-space:nowrap;
    }
    .sep{ opacity:0.5; }

    #fsWrap{
      position: fixed;
      right: 12px;
      top: calc(10px + env(safe-area-inset-top));
      z-index: 7;
      display: flex;
      pointer-events: auto;
    }
    #fsBtn{
      appearance:none;
      border: 1px solid rgba(255,255,255,0.18);
      background: var(--ui2);
      color: #fff;
      border-radius: 999px;
      padding: 10px 12px;
      font-weight: 800;
      cursor: pointer;
      backdrop-filter: blur(6px);
    }
    #fsBtn:active{ transform: translateY(1px); }

    .hint{
      margin-top: 10px;
      font-size: 12px;
      opacity: 0.85;
      line-height: 1.35;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="hud">
    <div id="score">
      <span id="scoreNow">Score: 0</span>
      <span class="sep">|</span>
      <span id="scoreBest">Best: 0</span>
    </div>
  </div>

  <div id="fsWrap">
    <button id="fsBtn" type="button" aria-label="Toggle Fullscreen">Fullscreen</button>
  </div>

  <div id="startOverlay" class="overlay">
    <div class="panel">
      <h1 class="title">How to Play</h1>
      <p class="text">
        Press <b>Start</b> to begin.<br/>
        Then tap/click anywhere to flap and stay in the air.<br/>
        Fly through the gaps between the purple columns.<br/>
        Each pair of columns you pass = <b>+1</b> point.<br/>
        If you hit a column or the ground, the game ends.
      </p>
      <button id="startBtn" class="btn">Start Game</button>
      <button id="startFsBtn" class="btn secondary">Start in Fullscreen</button>
      <div class="hint" id="fsHint"></div>
    </div>
  </div>

  <div id="gameOverOverlay" class="overlay hidden">
    <div class="panel">
      <h1 class="title">Game Over</h1>
      <p class="text" id="finalText">You passed 0 columns.</p>
      <button id="restartBtn" class="btn">Play Again</button>
      <button id="restartFsBtn" class="btn secondary">Play Again in Fullscreen</button>
      <div class="hint" id="fsHint2"></div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      const startOverlay = document.getElementById('startOverlay');
      const gameOverOverlay = document.getElementById('gameOverOverlay');
      const finalText = document.getElementById('finalText');

      const startBtn = document.getElementById('startBtn');
      const restartBtn = document.getElementById('restartBtn');

      const fsBtn = document.getElementById('fsBtn');
      const startFsBtn = document.getElementById('startFsBtn');
      const restartFsBtn = document.getElementById('restartFsBtn');
      const fsHint = document.getElementById('fsHint');
      const fsHint2 = document.getElementById('fsHint2');

      const scoreNowEl = document.getElementById('scoreNow');
      const scoreBestEl = document.getElementById('scoreBest');

      // stable mobile vh
      function setVhUnit() {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
      }
      window.addEventListener('resize', setVhUnit, { passive: true });
      window.addEventListener('orientationchange', setVhUnit, { passive: true });
      setVhUnit();

      // prevent scroll
      document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

      // fullscreen
      function isFullscreen() {
        return !!(document.fullscreenElement || document.webkitFullscreenElement);
      }
      function fullscreenAvailable() {
        const el = document.documentElement;
        return !!(el.requestFullscreen || el.webkitRequestFullscreen);
      }
      async function enterFullscreen() {
        const el = document.documentElement;
        try {
          if (el.requestFullscreen) await el.requestFullscreen();
          else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
        } catch (err) {}
      }
      async function exitFullscreen() {
        try {
          if (document.exitFullscreen) await document.exitFullscreen();
          else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
        } catch (err) {}
      }
      async function toggleFullscreen() {
        if (!fullscreenAvailable()) return;
        if (isFullscreen()) await exitFullscreen();
        else await enterFullscreen();
      }
      function updateFsUI() {
        const available = fullscreenAvailable();
        fsBtn.style.display = available ? 'inline-block' : 'none';
        startFsBtn.style.display = available ? 'block' : 'none';
        restartFsBtn.style.display = available ? 'block' : 'none';

        const msg = available
          ? 'Tip: Fullscreen may not work in some in-app browsers. For best results, open in Safari/Chrome.'
          : 'Fullscreen is not available in this browser.';
        fsHint.textContent = msg;
        fsHint2.textContent = msg;

        fsBtn.textContent = isFullscreen() ? 'Exit Fullscreen' : 'Fullscreen';
      }
      document.addEventListener('fullscreenchange', updateFsUI);
      document.addEventListener('webkitfullscreenchange', updateFsUI);
      fsBtn.addEventListener('click', toggleFullscreen);

      // best score
      const BEST_KEY = 'flappy_best_score_v4';
      function getBest() {
        const v = Number(localStorage.getItem(BEST_KEY));
        return Number.isFinite(v) ? v : 0;
      }
      function setBest(v) { localStorage.setItem(BEST_KEY, String(v)); }
      let bestScore = getBest();
      scoreBestEl.textContent = `Best: ${bestScore}`;

      // canvas resize
      function resizeCanvas(){
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        canvas.width = Math.floor(window.innerWidth * dpr);
        canvas.height = Math.floor(window.innerHeight * dpr);
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      window.addEventListener('resize', () => { setVhUnit(); resizeCanvas(); }, { passive:true });
      resizeCanvas();

      // assets
      const bg = new Image(); bg.src = 'o.png';
      const birdImg = new Image(); birdImg.src = 'i.png';

      // game state
      const state = {
        running:false,
        over:false,
        score:0,
        lastTime:0,
        pipes:[],
        spawnTimer:0,
        speedCurrent: 0,
        speedTarget: 0,
      };

      function scaleFactor(){
        return Math.max(0.85, Math.min(1.35, window.innerHeight / 700));
      }

      const bird = {
        x:0,
        y:0,
        yRender:0,
        vy:0,
        w:60,
        h:46,
        rotation:0,
        rotTarget:0
      };

      // pixel mask (alpha)
      const mask = {
        ready: false,
        w: 0,
        h: 0,
        alpha: null,
        thresh: 35
      };
      const maskCanvas = document.createElement('canvas');
      const maskCtx = maskCanvas.getContext('2d');

      function rebuildBirdMask() {
        mask.ready = false;
        mask.alpha = null;
        if (!birdImg.complete || !birdImg.naturalWidth) return;

        const w = Math.max(1, Math.floor(bird.w));
        const h = Math.max(1, Math.floor(bird.h));
        maskCanvas.width = w;
        maskCanvas.height = h;

        maskCtx.clearRect(0, 0, w, h);
        maskCtx.drawImage(birdImg, 0, 0, w, h);

        try {
          const data = maskCtx.getImageData(0, 0, w, h).data;
          const a = new Uint8ClampedArray(w * h);
          for (let i = 0, p = 0; i < data.length; i += 4, p++) a[p] = data[i + 3];
          mask.w = w;
          mask.h = h;
          mask.alpha = a;
          mask.ready = true;
        } catch (e) {
          console.warn('Mask build failed, using fallback hitbox collision.', e);
          mask.ready = false;
          mask.alpha = null;
        }
      }

      // pipes / speed
      function baseSpeed(){
        const s = scaleFactor();
        return 230 * s;
      }
      function targetSpeed(){
        const s = scaleFactor();
        return baseSpeed() + Math.min(260 * s, state.score * 10 * s);
      }
      function pipeSpawnInterval(){
        const s = scaleFactor();
        const min = 0.92;
        const max = 1.18;
        const k = Math.min(0.28, state.score * 0.008);
        return (max - k) * (1.0 / (0.95 + 0.15 * s)) + (min * 0.10);
      }

      function makePipePair(){
        const s = scaleFactor();
        const pipeW = Math.round(92 * s);

        // âœ… BIGGER GAP BETWEEN TOP/BOTTOM PIPES (only change requested)
        const minGap = 190 * s;
        const maxGap = 270 * s;
        const gap = Math.round(Math.max(minGap, Math.min(maxGap, window.innerHeight * 0.34)));

        const marginTop = Math.round(70 * s);
        const marginBottom = Math.round(90 * s);
        const usable = window.innerHeight - marginTop - marginBottom - gap;
        const gapY = marginTop + Math.random() * Math.max(60, usable);

        return { x: window.innerWidth + 12, w: pipeW, gapY, gapH: gap, passed:false };
      }

      // more maneuverable bird
      function gravity(){
        const s = scaleFactor();
        return 1380 * s;
      }
      function flapStrength(){
        const s = scaleFactor();
        return -560 * s;
      }
      function groundY(){ return window.innerHeight; }

      function resetGame(){
        const s = scaleFactor();
        state.running = false;
        state.over = false;
        state.score = 0;
        state.pipes = [];
        state.spawnTimer = 0;
        state.lastTime = 0;

        bird.w = Math.round(86 * s);
        bird.h = Math.round(66 * s);

        bird.x = Math.round(window.innerWidth * 0.28);
        bird.y = Math.round(window.innerHeight * 0.45);
        bird.yRender = bird.y;
        bird.vy = 0;

        bird.rotation = 0;
        bird.rotTarget = 0;

        const base = baseSpeed();
        state.speedCurrent = base;
        state.speedTarget = base;

        scoreNowEl.textContent = 'Score: 0';
        bestScore = getBest();
        scoreBestEl.textContent = `Best: ${bestScore}`;

        rebuildBirdMask();
      }

      function doFlap(){
        if (!state.running || state.over) return;
        bird.vy = flapStrength();
      }

      function startGame(){
        resetGame();
        startOverlay.classList.add('hidden');
        gameOverOverlay.classList.add('hidden');
        state.running = true;
        state.over = false;
        state.lastTime = performance.now();
        requestAnimationFrame(loop);
      }

      function endGame(){
        if (state.over) return;
        state.over = true;
        state.running = false;

        if (state.score > bestScore){
          bestScore = state.score;
          setBest(bestScore);
          scoreBestEl.textContent = `Best: ${bestScore}`;
        }
        finalText.textContent = `You passed ${state.score} columns. Best: ${bestScore}.`;
        gameOverOverlay.classList.remove('hidden');
      }

      // buttons
      startBtn.addEventListener('click', startGame);
      restartBtn.addEventListener('click', startGame);
      startFsBtn.addEventListener('click', async () => { await enterFullscreen(); startGame(); });
      restartFsBtn.addEventListener('click', async () => { await enterFullscreen(); startGame(); });

      // controls: Space still works, but instructions say Start
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          if (!state.running && !state.over && !startOverlay.classList.contains('hidden')) return; // require Start
          if (state.over) return;
          doFlap();
        }
      }, { passive:false });

      window.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        if (!state.running && !state.over && !startOverlay.classList.contains('hidden')) return; // require Start
        if (state.over) return;
        doFlap();
      }, { passive:false });

      let lastTouchTime = 0;
      window.addEventListener('touchend', (e) => {
        const now = Date.now();
        if (now - lastTouchTime <= 300) e.preventDefault();
        lastTouchTime = now;
      }, { passive:false });

      // drawing
      function drawBackground(){
        const w = window.innerWidth, h = window.innerHeight;
        if (bg.complete && bg.naturalWidth){
          const iw = bg.naturalWidth, ih = bg.naturalHeight;
          const scale = Math.max(w/iw, h/ih);
          const sw = iw*scale, sh = ih*scale;
          const sx = (w - sw)/2, sy = (h - sh)/2;
          ctx.drawImage(bg, sx, sy, sw, sh);
        } else {
          ctx.fillStyle = '#0b1020';
          ctx.fillRect(0,0,w,h);
        }
      }

      function roundRectPath(x,y,w,h,r){
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr, y);
        ctx.arcTo(x+w, y, x+w, y+h, rr);
        ctx.arcTo(x+w, y+h, x, y+h, rr);
        ctx.arcTo(x, y+h, x, y, rr);
        ctx.arcTo(x, y, x+w, y, rr);
        ctx.closePath();
      }

      function drawPipeCylinder(x,y,w,h){
        const r = Math.min(w*0.45, 26);

        roundRectPath(x,y,w,h,r);
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--pipe').trim();
        ctx.fill();

        const grad = ctx.createLinearGradient(x, 0, x+w, 0);
        grad.addColorStop(0.0, 'rgba(255,255,255,0.14)');
        grad.addColorStop(0.22, 'rgba(255,255,255,0.06)');
        grad.addColorStop(0.52, 'rgba(255,255,255,0.00)');
        grad.addColorStop(1.0, 'rgba(0,0,0,0.12)');

        ctx.save();
        ctx.globalCompositeOperation = 'source-atop';
        ctx.fillStyle = grad;
        ctx.fillRect(x,y,w,h);
        ctx.restore();

        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--pipe-dark').trim();
        ctx.lineWidth = 2;
        roundRectPath(x+0.5,y+0.5,w-1,h-1,r);
        ctx.stroke();
      }

      function drawPipes(){
        for (const p of state.pipes){
          drawPipeCylinder(p.x, 0, p.w, p.gapY);
          const by = p.gapY + p.gapH;
          drawPipeCylinder(p.x, by, p.w, window.innerHeight - by);
        }
      }

      function drawBird(dt){
        bird.rotTarget = Math.max(-0.45, Math.min(1.05, bird.vy / 980));
        const lerp = 1 - Math.pow(0.001, dt);
        bird.rotation += (bird.rotTarget - bird.rotation) * lerp * 0.18;

        // slightly faster render smoothing so it feels responsive
        bird.yRender += (bird.y - bird.yRender) * lerp * 0.42;

        const cx = bird.x + bird.w/2;
        const cy = bird.yRender + bird.h/2;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(bird.rotation);

        if (birdImg.complete && birdImg.naturalWidth){
          ctx.drawImage(birdImg, -bird.w/2, -bird.h/2, bird.w, bird.h);
        } else {
          ctx.beginPath();
          ctx.arc(0,0,Math.min(bird.w,bird.h)/2,0,Math.PI*2);
          ctx.fillStyle = '#fff';
          ctx.fill();
        }
        ctx.restore();
      }

      // collision helpers
      function rectOverlap(ax,ay,aw,ah,bx,by,bw,bh){
        const x1 = Math.max(ax, bx);
        const y1 = Math.max(ay, by);
        const x2 = Math.min(ax + aw, bx + bw);
        const y2 = Math.min(ay + ah, by + bh);
        if (x2 <= x1 || y2 <= y1) return null;
        return { x: x1, y: y1, w: x2 - x1, h: y2 - y1 };
      }

      function getBirdHitbox(){
        const shrink = 0.78;
        const hw = bird.w * shrink;
        const hh = bird.h * shrink;
        const hx = bird.x + (bird.w - hw)/2;
        const hy = bird.yRender + (bird.h - hh)/2;
        return { x:hx, y:hy, w:hw, h:hh };
      }

      function birdHitsRectPixelPerfect(rect){
        if (!mask.ready || !mask.alpha) {
          const hb = getBirdHitbox();
          return !!rectOverlap(hb.x, hb.y, hb.w, hb.h, rect.x, rect.y, rect.w, rect.h);
        }

        const bx = bird.x;
        const by = bird.yRender;
        const overlap = rectOverlap(bx, by, bird.w, bird.h, rect.x, rect.y, rect.w, rect.h);
        if (!overlap) return false;

        const sx = overlap.x - bx;
        const sy = overlap.y - by;

        const mw = mask.w;
        const alpha = mask.alpha;
        const thresh = mask.thresh;

        const startX = Math.max(0, Math.floor(sx));
        const startY = Math.max(0, Math.floor(sy));
        const endX = Math.min(mw, Math.ceil(sx + overlap.w));
        const endY = Math.min(mask.h, Math.ceil(sy + overlap.h));

        const step = 1;
        for (let y = startY; y < endY; y += step){
          const row = y * mw;
          for (let x = startX; x < endX; x += step){
            if (alpha[row + x] > thresh) return true;
          }
        }
        return false;
      }

      function checkCollisions(){
        const hb = getBirdHitbox();
        if (hb.y + hb.h >= window.innerHeight) return true;
        if (hb.y <= 0) return true;

        for (const p of state.pipes){
          const topRect = { x: p.x, y: 0, w: p.w, h: p.gapY };
          const by = p.gapY + p.gapH;
          const bottomRect = { x: p.x, y: by, w: p.w, h: window.innerHeight - by };

          if (rectOverlap(hb.x, hb.y, hb.w, hb.h, topRect.x, topRect.y, topRect.w, topRect.h)) {
            if (birdHitsRectPixelPerfect(topRect)) return true;
          }
          if (rectOverlap(hb.x, hb.y, hb.w, hb.h, bottomRect.x, bottomRect.y, bottomRect.w, bottomRect.h)) {
            if (birdHitsRectPixelPerfect(bottomRect)) return true;
          }
        }
        return false;
      }

      function update(dt){
        // smooth speed increase
        state.speedTarget = baseSpeed() + Math.min(260 * scaleFactor(), state.score * 10 * scaleFactor());
        const smoothing = 1 - Math.pow(0.001, dt);
        state.speedCurrent += (state.speedTarget - state.speedCurrent) * smoothing * 0.12;

        state.spawnTimer -= dt;
        if (state.spawnTimer <= 0){
          state.pipes.push(makePipePair());
          state.spawnTimer = pipeSpawnInterval();
        }

        const speed = state.speedCurrent;
        for (const p of state.pipes){
          p.x -= speed * dt;
          const mid = p.x + p.w;
          if (!p.passed && mid < bird.x){
            p.passed = true;
            state.score += 1;
            scoreNowEl.textContent = `Score: ${state.score}`;
          }
        }
        state.pipes = state.pipes.filter(p => p.x + p.w > -30);

        bird.vy += gravity() * dt;

        // less damping => more responsive
        bird.vy *= Math.pow(0.997, dt * 60);

        bird.y += bird.vy * dt;

        if (checkCollisions()) endGame();
      }

      function render(dt){
        ctx.clearRect(0,0,window.innerWidth, window.innerHeight);
        drawBackground();
        drawPipes();
        drawBird(dt);
      }

      function loop(t){
        if (!state.running){ render(1/60); return; }
        const dt = Math.min(0.033, Math.max(0, (t - state.lastTime) / 1000));
        state.lastTime = t;
        update(dt);
        render(dt);
        if (state.running) requestAnimationFrame(loop);
      }

      // boot
      updateFsUI();
      resetGame();
      startOverlay.classList.remove('hidden');
      gameOverOverlay.classList.add('hidden');

      birdImg.addEventListener('load', () => rebuildBirdMask());
      window.addEventListener('resize', () => rebuildBirdMask(), { passive: true });

      bg.addEventListener('error', () => console.warn('Background image o.png not found.'));
      birdImg.addEventListener('error', () => console.warn('Character image i.png not found.'));
    })();
  </script>
</body>
</html>
